
/*
2-3)
BruteForceChange ( M, c, d ){ 		  //M은 맞춰야하는 수, c는 M을 구성하기 위한 수가 저장된 배열, d는 c배열의 크기  입니다.

 	for(i=0 to d;i++){k[i]=M/c[i];}  // 나눈 몫을 k[i]배열에 모두 저장하는데 정수형으로 저장합니다.
 	
 	result=k[4];					// 최대의 많은 빈도를 가지게 되는 값을 일단 result에 초기 값으로 줍니다.
 	
 	 for each (k[0] , k[1] , … , k[d-1] ) from (0,…,0) to (M/c[10],…,M/c[d-1])
 	{ 
 	
 		valueOfCoin=c[0]*q+c[1]*w+c[2]*e+c[3]*r+c[4]*t;  // M을 구성하게 되는 모든 경우의 수를 전부 구해봅니다. 
							if(valueOfCoin==M) {		// 구한 값이 M 과 같다면,
								sum=q+w+e+r+t;  		// sum이라는 변수에 q,w,e,r,t의 합을 저장합니다
														//q,w,e,r,t는 각각 c배열 인덱스에 해당하는 값을 사용한 빈도수라고 할 수 있습니다.
								if(result>sum) {		// result의 값은 가장 작은 값을 선택하는 것이므로,
									result=sum; 		// result보다 작은 경우에만 result에 저장합니다
								}
							}
 	
 		return result;
 	}
 	
 	

}
*/
//2015112120 임성두
package week1;
import java.util.Scanner;

public class no2_4{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int M=40;
		int d=sc.nextInt();// 코인의 종류의 수를 입력받습니다
		int []c= new int[d];
		for(int i=0;i<d;i++) {// 코인의 종류를 입력받습니다
			c[i]=sc.nextInt();
		}
	
		System.out.println(bruteforce(M, c, d));
	}
	public static int bruteforce(int M,int[]c,int d) {
		if(M==0) {
			return 0;
		}
		int result=1000;// 임의로 상대적으로 큰수르 지정했습니다.
		for(int i=0;i<d;i++) {
			if(M>=c[i]) {
				int brut=bruteforce(M-c[i],c,d)+1; 
				// 현재 인덱스 i 에 해당하는 c[i]의 값보다 M이 크면 M-c[i]를 하고 재귀함수를 호출합니다
				// +1은 사용한 코인의 수를 증가 시키는 것 입니다.
				if(result>brut)
					result=brut;
			}
		}// for 문이 끝나면 위 if 문에서 result의 최솟값을 찾게 됩니다.
return result;
	}
}
