package algorithm_dnaprj;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Scanner;

public class prj2 {
    static ArrayList<ArrayList<String>> resultList;
    static ArrayList<String> resultString;
    static int COUNT=0;
    static int DENOVCOUNT=0;

    // 50만
    //1000/5000-10     27% 잘 안되네
    //1000/5000/ 7
    
    //1000/7000/ 10     0.034% / 0.09 /0.09
    //1500 5000 500000 10 0.4% / 7 / 잘 안도미
    //250 20000 500000 10  0.3// 잘 안됨
    //500000 2000 3000 10 0.49 0.41  0.3 0.449
    
    

    //10만
   
    //10만 100/2000/ 10   실패
    // 10만/ 200/3000/ 10  실패
    // 10만 / 500/1000/10   실패
    
    //10만 500 2000 100000 10   0.3 /0.4/0.4/0.4
    
    //250 4000 100000 10 0.46 /6% 간혹 실패 
    
    //5만
    //300 2500 50000 10   0.75% /0.67 /0.91/0.91
    
    //250 2000 50000 10   0.28% 0.4% /0.44% 간혹 실패....
    @SuppressWarnings("unchecked")
	public static void main(String[] args) throws IOException {

        Scanner sc=new Scanner(System.in);
      
        System.out.print("mydna의 길이 입력 : ");
		int l=sc.nextInt();//50만
        System.out.print("shortread 문자열 하나의 길이 입력 : ");
        int k=sc.nextInt();//50만 기준 2000
        System.out.print("shortread 개수 입력: ");
        int n=sc.nextInt();//50만 기준 3000
       
        makemydna.make(k,n,l);
		  ArrayList<String> shortread=fileshort();
	      
		System.out.println("일치 최소 개수 입력 : ");
        int r=sc.nextInt(); // 몇개까지 일치하면 합칠 것 인지를 결정합니다.
     brute(shortread,r,l,k);
        System.out.println(COUNT);
        sc.close();
        compare_denov.compare(l);
    }
    @SuppressWarnings("unchecked")
    static void brute(ArrayList<String>shortread,int r,int l,int k) throws IOException {
       
        
        System.out.println("length = "+shortread.size());
          
            denov(shortread,shortread.remove(0),r,l,k); 
            // 첫 번째 shortread를 시작으로 하여 알고리즘을 진행합니다.
            // 제한 사항 - shortread의 0번 인덱스를 항상 시작 점으로 둔다(mydna의 시작점을 shortread의 0범 인덱스에 저장 시켜 놓음)
            // 바로 밑에 주석처리 코드는 원래 denove알고리즘의 목적과 맞지만, bruteforce로서 상당한 시간을 요구하기에 위 처럼 제한 사항을 둡니다.
/*   ArrayList<String> shorttmp;
 *   shorttmp=(ArrayList<String>) shortread.clone();
 *   for(int i=0;i<shortread.length();i++){
 * shorttmp=(ArrayList<String>) shortread.clone();
 *  denov(shortread,shortread.remove(i),r,l,k);
 * }
 * 
 * */
    }
    @SuppressWarnings("unchecked")
	static int denov(ArrayList<String> shorttmp,String res,int r,int l,int k) throws IOException {


        int len_short=k;//short의 길이



        DENOVCOUNT++;
        String result=res;
            System.out.println("count: "+DENOVCOUNT+", "+result.length());
        if(DENOVCOUNT>=1000){ 
        	// 재귀적으로 호출하는 함수가 1000회 이상일 때 어느정도 길이가 만들어 졌다면 파일에 쓰고 메서드를 종료합니다
            if(result.length()>l*0.95)
            { writefile(result);
            return 1;}else if(result.length()<l*0.75) {
            	//길이가 75% 미만이 만들어 졌다면 계속 진행합니다.
            	return 0;
            }
           
        }

        String compare,subtmp, subtmp2, subtmp3;
        int d,j,rl,rindex,ret,subrl;
        ArrayList<String>tmp;
        int len=shorttmp.size();
       
        for(j=0;j<len;j++) {

            if(result.length()>=l*0.995) {
                writefile(result);
                return 1;
            }
            compare=shorttmp.get(j);
            subtmp=compare.substring(0,r);
            subtmp2=compare.substring(r);
            if(result.contains(subtmp)) {
                rindex=result.lastIndexOf(subtmp);
                rl=result.length();
                subrl=rl-rindex;
                if(subrl==r) {
                    result+=subtmp2;
                    tmp=(ArrayList<String>) shorttmp.clone();
                    tmp.remove(j);len--;
                    //Collections.shuffle(tmp);
                   ret= denov(tmp,result,r,l,k);
                   if(ret==1) {return 1;}
                }else if(subrl<len_short&&subrl>r) {
                    d=subrl-r;
                    subtmp3=subtmp2.substring(0,d);
                    if(result.substring(rl-d).equals(subtmp3)) {
                        result+=subtmp2.substring(d);
                        tmp=(ArrayList<String>) shorttmp.clone();
                        tmp.remove(j);len--;
                     //   Collections.shuffle(tmp);
                      ret=  denov(tmp,result,r,l,k);
                      if (ret==1) {  return 1;}
                    }
                }

            }
           }
        if(result.length()>=l*0.995) {
            writefile(result);
             return 1;
        }
        return 0;
    }
static void writefile(String result){
                try {
                	 PrintWriter pw;
 					pw = new PrintWriter("C:/Users/bohee/Desktop/denov.txt");
                pw.print(result);
                pw.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } 
}
    static ArrayList<String> fileshort() {
        ArrayList<String> strlist=new ArrayList<String>();
        BufferedReader br;
        try {
            String str;
            br = new BufferedReader(new FileReader("C:/Users/bohee/Desktop/shortread.txt"));
            while(true) {
                str=br.readLine();
                if(str==null)
                { break;}
                strlist.add(str);
            }br.close();
        } catch ( IOException e) {
            e.printStackTrace();
        }
        return strlist;
    }
}
